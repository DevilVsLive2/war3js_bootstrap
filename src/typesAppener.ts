/* eslint-disable @typescript-eslint/no-unused-vars */

import {
    Project,
    SyntaxKind,
    ClassDeclaration,
    InterfaceDeclaration,
    EnumDeclaration,
    FunctionDeclaration,
    VariableDeclaration,
    TypeAliasDeclaration,
    VariableDeclarationKind,
    FunctionDeclarationStructure,
    Scope,
    StructureKind,
    ExportedDeclarations,
    ModuleDeclaration,
    ModuleDeclarationKind,
} from "ts-morph";
import path from "path";

import * as bootstrapExport from "./index.js";
import { AutoMappedMethodMetadata, getMethodMeta, isClassHasModified } from "./services/HandleBuilder.js";
import { getListNatives } from "@war3js/unsafe";

const project = new Project();
const configSourceFile = project.addSourceFileAtPath("./.typesAppenderConfig.d.ts");

const nativeTypeMappingInterface = configSourceFile.getInterfaceOrThrow("__ColnfigOnlyTypeToHandle");

const inputFilePath = configSourceFile
    .getVariableDeclarationOrThrow("__ColnfigOnlyBundlePath")
    .getInitializerIfKind(SyntaxKind.StringLiteral)
    .getLiteralText();

const outputBundlleFilePath = configSourceFile
    .getVariableDeclarationOrThrow("__ColnfigOnlyFixedBundleOutPath")
    .getInitializerIfKind(SyntaxKind.StringLiteral)
    .getLiteralText();

const outputNativesFilePath = configSourceFile
    .getVariableDeclarationOrThrow("__ColnfigOnlyNativesOutPath")
    .getInitializerIfKind(SyntaxKind.StringLiteral)
    .getLiteralText();

const inputBundleFile = project.addSourceFileAtPath(inputFilePath);

const outputBundlleFile = project.createSourceFile(outputBundlleFilePath, "", {
    overwrite: true,
});

const nativesSourceFile = project.createSourceFile(outputNativesFilePath, "", {
    overwrite: true,
});

const exportedDeclarations = Array.from(inputBundleFile.getExportedDeclarations().values()).flat();

// Move all export to global

let declareGlobalBlock = inputBundleFile.getModule("global");

if (!declareGlobalBlock) {
    declareGlobalBlock = inputBundleFile.addModule({
        name: "global",
        hasDeclareKeyword: true,
        declarationKind: ModuleDeclarationKind.Global,
    });
}

// Append chain property type

// export type ChainPropertyMethodSign<T, C> = ;

/*
declareGlobalBlock.addTypeAlias({
    name: "ChainPropertyMethodSign",
    type: "(() => T) | ((value: T | ((this: C, currentValue: T) => T)) => void)",
    typeParameters: ["T,C"],
});
*/

moveExportToGlobal(exportedDeclarations, declareGlobalBlock);

// Append autogenerated methods

Object.keys(bootstrapExport).forEach((key) => {
    const value = (bootstrapExport as any)[key];

    if (isClassHasModified(value)) {
        const className = value.name;
        const classDeclaration = declareGlobalBlock.getClassOrThrow(className);

        Object.entries(value.prototype).forEach((entry) => {
            const [memberName, memberValue] = entry;

            if (typeof memberValue === "function") {
                const methodMetadata = getMethodMeta(memberValue);

                if (methodMetadata) appendGeneratedClassMethod(classDeclaration, memberName, methodMetadata);
            }
        });
    }
});

nativesSourceFile.addStatements("// eslint-disable-next-line @typescript-eslint/triple-slash-reference");
nativesSourceFile.addStatements(
    `/// <reference path="${path.relative(path.dirname(outputNativesFilePath), outputBundlleFilePath)}" />`,
);

let declareNativesBlock = nativesSourceFile.getModule("natives");

if (!declareNativesBlock) {
    declareNativesBlock = nativesSourceFile.addModule({
        name: '"natives"',
        declarationKind: ModuleDeclarationKind.Module,
        hasDeclareKeyword: true,
    });
}

// Save output bundle file

inputBundleFile.forEachChild((child) => {
    outputBundlleFile.addStatements(child.getText());
});

outputBundlleFile.saveSync();

// Append natives package

const nativesList = getListNatives();

Object.entries(nativesList).forEach((entry) => {
    const nativeName = entry[0];
    const nativeFunction = entry[1];

    declareNativesBlock.addFunction({
        name: nativeName,
        parameters: nativeFunction.parametres.map((argType, i) => {
            return {
                type: convertJassTypeToJsType(argType),
                name: `arg${i + 1}`,
            };
        }),

        returnType: convertJassTypeToJsType(nativeFunction.returnType),
    });
});

nativesSourceFile.saveSync();

function convertJassTypeToJsType(typeName: string): string {
    return nativeTypeMappingInterface.getProperty(typeName)?.getTypeNode()?.getText() || "unknown";
}

function moveExportToGlobal(exportedDeclarations: ExportedDeclarations[], globalBlock: ModuleDeclaration) {
    exportedDeclarations.forEach((declaration) => {
        if (declaration instanceof ClassDeclaration) {
            const structure = declaration.getStructure();
            structure.hasDeclareKeyword = false;
            structure.isExported = false;
            declareGlobalBlock.addClass(structure);
        } else if (declaration instanceof InterfaceDeclaration) {
            const structure = declaration.getStructure();
            structure.isExported = false;
            declareGlobalBlock.addInterface(structure);
        } else if (declaration instanceof EnumDeclaration) {
            const structure = declaration.getStructure();
            structure.isExported = false;
            declareGlobalBlock.addEnum(structure);
        } else if (declaration instanceof VariableDeclaration) {
            declareGlobalBlock.addVariableStatement({
                declarationKind: VariableDeclarationKind.Const,
                declarations: [declaration.getStructure()],
            });
        } else if (declaration instanceof TypeAliasDeclaration) {
            declareGlobalBlock.addTypeAlias(declaration.getStructure());
        } else if (declaration instanceof FunctionDeclaration) {
            declareGlobalBlock.addFunction(declaration.getStructure() as FunctionDeclarationStructure);
        } else {
            throw new Error("Unknown export declaration kind");
        }

        declaration.remove();
    });
}

function appendGeneratedClassMethod(declaration: ClassDeclaration, name: string, metadata: AutoMappedMethodMetadata) {
    switch (metadata.methodType) {
        case "method": {
            declaration.addMember({
                kind: StructureKind.Method,
                name,
                scope: Scope.Public,
                parameters: metadata.argTypes.map((argType, i) => {
                    return {
                        type: convertJassTypeToJsType(argType),
                        name: `arg${i + 1}`,
                    };
                }),

                returnType: convertJassTypeToJsType(metadata.returnType),
            });

            break;
        }
        case "chainProperty": {
            /*
            declaration.addMember({
                kind: StructureKind.Property,
                name,
                scope: Scope.Public,
                type: `ChainPropertyMethodSign<${convertJassTypeToJsType(metadata.type)}, this>`,
            });
            */

            // Getter
            declaration.addMember({
                kind: StructureKind.Method,
                name,
                scope: Scope.Public,
                parameters: [],

                returnType: convertJassTypeToJsType(metadata.type),
            });

            //Setter
            declaration.addMember({
                kind: StructureKind.Method,
                name,
                scope: Scope.Public,
                typeParameters: [`T = ${convertJassTypeToJsType(metadata.type)}`],
                parameters: [
                    {
                        name: "value",
                        type: `T | ((this: this, currentValue: T) => T)`,
                    },
                ],

                returnType: "this",
            });

            break;
        }
    }
}
